trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: (.
trace: a.
trace:  . .
trace: b.
trace: ).
trace: 
.
trace: > .
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: (.
trace: a.
trace:  . .
trace: b.
trace: ).
trace: 
.
trace: > .
trace: LPIA> .
trace: Fatal error: .
trace: run out of cells  --- unable to recover cells.
trace: 
.
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: 
No code
.
trace: 
No code
.
trace: a.
trace: 
.
trace: > .
trace: 
No code
.
trace: 
No code
.
trace: EOF.
trace: 
.
trace: > .
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: (.
trace: a.
trace:  . .
trace: b.
trace: ).
trace: 
.
trace: > .
trace: (.
trace: a.
trace:  . .
trace: b.
trace: ).
trace: 
.
trace: > .
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: (.
trace: a.
trace:  . .
trace: b.
trace: ).
trace: 
.
trace: > .
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: (.
trace: a.
trace:  .
trace: b.
trace:  .
trace: c.
trace: ).
trace: 
.
trace: > .
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: 
No code
.
trace: 
No code
.
trace: Test.
trace: 
.
trace: > .
trace: Hello, This is Mini-Scheme Interpreter Version 0.85k4-a.
.
trace: loading init.scm.
trace: 
.
trace: ; This is a init file for Mini-Scheme.
.
trace: 
.
trace: 
.
trace: 
.
trace: ;; fake pre R^3 boolean values
.
trace: 
.
trace: (define nil #f)
.
trace: 
.
trace: nil.
trace: 
.
trace: (define t #t)
.
trace: 
.
trace: t.
trace: 
.
trace: 
.
trace: 
.
trace: (define (caar x) (car (car x)))
.
trace: 
.
trace: caar.
trace: 
.
trace: (define (cadr x) (car (cdr x)))
.
trace: 
.
trace: cadr.
trace: 
.
trace: (define (cdar x) (cdr (car x)))
.
trace: 
.
trace: cdar.
trace: 
.
trace: (define (cddr x) (cdr (cdr x)))
.
trace: 
.
trace: cddr.
trace: 
.
trace: (define (caaar x) (car (car (car x))))
.
trace: 
.
trace: caaar.
trace: 
.
trace: (define (caadr x) (car (car (cdr x))))
.
trace: 
.
trace: caadr.
trace: 
.
trace: (define (cadar x) (car (cdr (car x))))
.
trace: 
.
trace: cadar.
trace: 
.
trace: (define (caddr x) (car (cdr (cdr x))))
.
trace: 
.
trace: caddr.
trace: 
.
trace: (define (cdaar x) (cdr (car (car x))))
.
trace: 
.
trace: cdaar.
trace: 
.
trace: (define (cdadr x) (cdr (car (cdr x))))
.
trace: 
.
trace: cdadr.
trace: 
.
trace: (define (cddar x) (cdr (cdr (car x))))
.
trace: 
.
trace: cddar.
trace: 
.
trace: (define (cdddr x) (cdr (cdr (cdr x))))
.
trace: 
.
trace: cdddr.
trace: 
.
trace: (define (cadddr x) (car (cdr (cdr (cdr x)))))
.
trace: 
.
trace: cadddr.
trace: 
.
trace: 
.
trace: 
.
trace: (define call/cc call-with-current-continuation)
.
trace: 
.
trace: call/cc.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list . x) x)
.
trace: 
.
trace: list.
trace: 
.
trace: 
.
trace: 
.
trace: (define (map proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (cons (proc (car list)) (map proc (cdr list)))))
.
trace: 
.
trace: map.
trace: 
.
trace: 
.
trace: 
.
trace: (define (for-each proc list)
.
trace: 
.
trace:     (if (pair? list)
.
trace: 
.
trace:         (begin (proc (car list)) (for-each proc (cdr list)))
.
trace: 
.
trace:         #t ))
.
trace: 
.
trace: for-each.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-tail x k)
.
trace: 
.
trace:     (if (zero? k)
.
trace: 
.
trace:         x
.
trace: 
.
trace:         (list-tail (cdr x) (- k 1))))
.
trace: 
.
trace: list-tail.
trace: 
.
trace: 
.
trace: 
.
trace: (define (list-ref x k)
.
trace: 
.
trace:     (car (list-tail x k)))
.
trace: 
.
trace: list-ref.
trace: 
.
trace: 
.
trace: 
.
trace: (define (last-pair x)
.
trace: 
.
trace:     (if (pair? (cdr x))
.
trace: 
.
trace:         (last-pair (cdr x))
.
trace: 
.
trace:         x))
.
trace: 
.
trace: last-pair.
trace: 
.
trace: 
.
trace: 
.
trace: (define (head stream) (car stream))
.
trace: 
.
trace: head.
trace: 
.
trace: 
.
trace: 
.
trace: (define (tail stream) (force (cdr stream)))
.
trace: 
.
trace: tail.
trace: 
.
trace: 
.
trace: 
.
trace: ;; The following quasiquote macro is due to Eric S. Tiedemann.
.
trace: 
.
trace: ;;   Copyright 1988 by Eric S. Tiedemann; all rights reserved.
.
trace: 
.
trace: ;; 
.
trace: 
.
trace: ;; --- If you don't use macro or quasiquote, cut below. ---
.
trace: 
.
trace: 
.
trace: 
.
trace: (macro 
.
trace: 
.
trace:  quasiquote 
.
trace: 
.
trace:  (lambda (l)
.
trace: 
.
trace:    (define (mcons f l r)
.
trace: 
.
trace:      (if (and (pair? r)
.
trace: 
.
trace:               (eq? (car r) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr r)) (cdr f))
.
trace: 
.
trace:               (pair? l)
.
trace: 
.
trace:               (eq? (car l) 'quote)
.
trace: 
.
trace:               (eq? (car (cdr l)) (car f)))
.
trace: 
.
trace:          (list 'quote f)
.
trace: 
.
trace:          (list 'cons l r)))
.
trace: 
.
trace:    (define (mappend f l r)
.
trace: 
.
trace:      (if (or (null? (cdr f))
.
trace: 
.
trace:              (and (pair? r)
.
trace: 
.
trace:                   (eq? (car r) 'quote)
.
trace: 
.
trace:                   (eq? (car (cdr r)) '())))
.
trace: 
.
trace:          l
.
trace: 
.
trace:          (list 'append l r)))
.
trace: 
.
trace:    (define (foo level form)
.
trace: 
.
trace:      (cond ((not (pair? form)) (list 'quote form))
.
trace: 
.
trace:            ((eq? 'quasiquote (car form))
.
trace: 
.
trace:             (mcons form ''quasiquote (foo (+ level 1) (cdr form))))
.
trace: 
.
trace:            (#t (if (zero? level)
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) (car (cdr form)))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (error "Unquote-splicing wasn't in a list:" 
.
trace: 
.
trace:                                  form))
.
trace: 
.
trace:                          ((and (pair? (car form)) 
.
trace: 
.
trace:                                (eq? (car (car form)) 'unquote-splicing))
.
trace: 
.
trace:                           (mappend form (car (cdr (car form))) 
.
trace: 
.
trace:                                    (foo level (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))
.
trace: 
.
trace:                    (cond ((eq? (car form) 'unquote) 
.
trace: 
.
trace:                           (mcons form ''unquote (foo (- level 1) 
.
trace: 
.
trace:                                                      (cdr form))))
.
trace: 
.
trace:                          ((eq? (car form) 'unquote-splicing)
.
trace: 
.
trace:                           (mcons form ''unquote-splicing
.
trace: 
.
trace:                                       (foo (- level 1) (cdr form))))
.
trace: 
.
trace:                          (#t (mcons form (foo level (car form))
.
trace: 
.
trace:                                          (foo level (cdr form)))))))))
.
trace: 
.
trace:    (foo 0 (car (cdr l)))))
.
trace: 
.
trace: quasiquote.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;; following part is written by a.k
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	atom?
.
trace: 
.
trace: (define (atom? x)
.
trace: 
.
trace:   (not (pair? x)))
.
trace: 
.
trace: atom?.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	memq
.
trace: 
.
trace: (define (memq obj lst)
.
trace: 
.
trace:   (cond
.
trace: 
.
trace:     ((null? lst) #f)
.
trace: 
.
trace:     ((eq? obj (car lst)) lst)
.
trace: 
.
trace:     (else (memq obj (cdr lst)))))
.
trace: 
.
trace: memq.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;    equal?
.
trace: 
.
trace: (define (equal? x y)
.
trace: 
.
trace:   (if (pair? x)
.
trace: 
.
trace:     (and (pair? y)
.
trace: 
.
trace:          (equal? (car x) (car y))
.
trace: 
.
trace:          (equal? (cdr x) (cdr y)))
.
trace: 
.
trace:     (and (not (pair? y))
.
trace: 
.
trace:          (eqv? x y))))
.
trace: 
.
trace: equal?.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: ;;;;	(do ((var init inc) ...) (endtest result ...) body ...)
.
trace: 
.
trace: ;;
.
trace: 
.
trace: (macro do
.
trace: 
.
trace:   (lambda (do-macro)
.
trace: 
.
trace:     (apply (lambda (do vars endtest . body)
.
trace: 
.
trace:              (let ((do-loop (gensym)))
.
trace: 
.
trace:                `(letrec ((,do-loop
.
trace: 
.
trace:                            (lambda ,(map (lambda (x)
.
trace: 
.
trace:                                            (if (pair? x) (car x) x))
.
trace: 
.
trace:                                       `,vars)
.
trace: 
.
trace:                              (if ,(car endtest)
.
trace: 
.
trace:                                (begin ,@(cdr endtest))
.
trace: 
.
trace:                                (begin
.
trace: 
.
trace:                                  ,@body
.
trace: 
.
trace:                                  (,do-loop
.
trace: 
.
trace:                                    ,@(map (lambda (x)
.
trace: 
.
trace:                                             (cond
.
trace: 
.
trace:                                               ((not (pair? x)) x)
.
trace: 
.
trace:                                               ((< (length x) 3) (car x))
.
trace: 
.
trace:                                               (else (car (cdr (cdr x))))))
.
trace: 
.
trace:                                        `,vars)))))))
.
trace: 
.
trace:                   (,do-loop
.
trace: 
.
trace:                     ,@(map (lambda (x)
.
trace: 
.
trace:                              (if (and (pair? x) (cdr x))
.
trace: 
.
trace:                                (car (cdr x))
.
trace: 
.
trace:                                nil))
.
trace: 
.
trace:                         `,vars)))))
.
trace: 
.
trace:       do-macro)))
.
trace: 
.
trace: do.
trace: 
.
trace: 
.
trace: 
.
trace: (define (assoc thing alist)
.
trace: 
.
trace:    (if (not (pair? alist))
.
trace: 
.
trace:        #f
.
trace: 
.
trace:        (if (equal? (car (car alist)) thing)
.
trace: 
.
trace:            (car alist)
.
trace: 
.
trace:            (assoc thing (cdr alist)))))
.
trace: 
.
trace: assoc.
trace: 
.
trace: 
.
trace: 
.
trace: (define sym-num 0)
.
trace: 
.
trace: sym-num.
trace: 
.
trace: 
.
trace: 
.
trace: (define (gensym)
.
trace: 
.
trace:   (set! sym-num (+ 1 sym-num))
.
trace: 
.
trace:   (make-symbol (format-int "GEN-%d" sym-num)))
.
trace: 
.
trace: gensym.
trace: 
.
trace: 
.
trace: 
.
trace: (define (modulo a b)
.
trace: 
.
trace:   (let ((rem (remainder a b)))
.
trace: 
.
trace:     (cond ((zero? rem) 0)
.
trace: 
.
trace:       ((eq? (negative? a) (negative? b)) rem)
.
trace: 
.
trace:       (else (+ b rem)))))
.
trace: 
.
trace: modulo.
trace: 
.
trace: 
.
trace: 
.
trace: (define (mb s) 
.
trace: 
.
trace:  (call "MessageBox" (val-ext "ghwnd") (unicode-of-ascii s) (unicode-of-ascii "Message") 0))
.
trace: 
.
trace: mb.
trace: 
.
trace: 
.
trace: 
.
trace: (define (member x l)
.
trace: 
.
trace:   (if (not (pair? l)) '()
.
trace: 
.
trace:       (if (equal? x (car l)) l
.
trace: 
.
trace: 	  (member x (cdr l)))))
.
trace: 
.
trace: member.
trace: 
.
trace: 
.
trace: 
.
trace: (define (length l)
.
trace: 
.
trace:   (if (not (pair? l)) 0
.
trace: 
.
trace:     (+ 1 (length (cdr l)))))
.
trace: 
.
trace: length.
trace: 
.
trace: 
.
trace: 
.
trace: (define (random n)
.
trace: 
.
trace:   (modulo (call "rand") n))
.
trace: 
.
trace: random.
trace: 
.
trace: 
.
trace: 
.
trace: (define (TOPLPIA) 
.
trace: 
.
trace:  (LPIA '(Q "init.lpi" READFILE EXEC Y ("LPIA> " PRINTSTRING READ EXEC) ELPIA)))
.
trace: 
.
trace: TOPLPIA.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: 
.
trace: > .
trace: 
No code
.
trace: 
No code
.
trace: Test.
trace: 
.
trace: > .
trace: 
No code
.
trace: 
No code
.
trace: (.
trace: aaa.
trace:  .
trace: bbb.
trace:  .
trace: ccc.
trace: ).
trace: 
.
trace: > .
trace: LPIA> .
trace: (.
trace: b.
trace:  . .
trace: a.
trace: ).
trace: 
.
trace: LPIA> .
trace: (.
trace: def.
trace:  .
trace: test.
trace:  .
trace: (.
trace: CDR.
trace:  .
trace: CAR.
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: CADDR.
trace:  .
trace: (.
trace: CDR.
trace:  .
trace: CDR.
trace:  .
trace: CAR.
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: CONTIENT.
trace:  .
trace: (.
trace: C.
trace:  .
trace: Q.
trace:  .
trace: (.
trace: ARG.
trace:  .
trace: _f.
trace:  .
trace: (.
trace:  ... .
trace:  .
trace:  ... .
trace:  .... .
trace: ).
trace:  .... .
trace: ).
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: UNLIST.
trace:  .
trace: (.
trace: ARG.
trace:  .
trace: l.
trace:  .
trace: (.
trace: (.
trace:  ... .
trace:  .
trace:  ... .
trace:  .... .
trace: ).
trace:  .
trace: NCONSPTHEN.
trace:  .
trace: I.
trace:  .... .
trace: ).
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: ONEOF.
trace:  .
trace: (.
trace: ARG.
trace:  .
trace: l.
trace:  .
trace: (.
trace: (.
trace:  ... .
trace:  .
trace:  ... .
trace:  .... .
trace: ).
trace:  .
trace: NCONSPTHEN.
trace:  .
trace: END.
trace:  .... .
trace: ).
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: AND.
trace:  .
trace: (.
trace: C.
trace:  .
trace: THEN.
trace:  .
trace: (.
trace: Q.
trace:  .
trace: ().
trace: ).
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: OR.
trace:  .
trace: (.
trace: B.
trace:  .
trace: (.
trace: REP.
trace:  .
trace: THEN.
trace:  .
trace: I.
trace:  .... .
trace: ).
trace:  .
trace: DEP.
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: EXIT.
trace:  .
trace: KI.
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: TOP.
trace:  .
trace: (.
trace: Y.
trace:  .
trace: (.
trace: "LPIA> ".
trace:  .
trace: PRINTSTRING.
trace:  .
trace: READ.
trace:  .... .
trace: ).
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: T.
trace:  .
trace: (.
trace: Q.
trace:  .
trace: T.
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: UNDEF.
trace:  .
trace: (.
trace: Q.
trace:  .
trace: UNDEFINED.
trace: ).
trace: ).
trace: 
.
trace: (.
trace: Q.
trace:  .
trace: (.
trace: 0.
trace:  .
trace: 0.
trace: ).
trace:  .
trace: SETSTRAT.
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: synonym.
trace:  .
trace: def.
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: GETPRIO.
trace:  .
trace: (.
trace: GETSTRAT.
trace:  .
trace: CAR.
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: SETPRIO.
trace:  .
trace: (.
trace: ARG.
trace:  .
trace: i.
trace:  .
trace: (.
trace: GETSTRAT.
trace:  .
trace: ARG.
trace:  .
trace: (.
trace:  ... .
trace:  . .
trace: s.
trace: ).
trace:  .... .
trace: ).
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: GETINCR.
trace:  .
trace: (.
trace: GETSTRAT.
trace:  .
trace: CDR.
trace:  .
trace: CAR.
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: SETINCR.
trace:  .
trace: (.
trace: ARG.
trace:  .
trace: i.
trace:  .
trace: (.
trace: GETSTRAT.
trace:  .
trace: ARG.
trace:  .
trace: (.
trace:  ... .
trace:  .
trace:  ... .
trace:  .... .
trace: ).
trace:  .... .
trace: ).
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: MAJPRIO.
trace:  .
trace: (.
trace: GETPRIO.
trace:  .
trace: GETINCR.
trace:  .
trace: PLUS.
trace:  .
trace: SETPRIO.
trace:  .... .
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: INCRPRIO.
trace:  .
trace: (.
trace: ARG.
trace:  .
trace: i.
trace:  .
trace: (.
trace: GETSTRAT.
trace:  .
trace: ARG.
trace:  .
trace: (.
trace:  ... .
trace:  . .
trace: s.
trace: ).
trace:  .... .
trace: ).
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: SCHEDULE.
trace:  .
trace: (.
trace: ALT.
trace:  .
trace: END.
trace:  .
trace: I.
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: ALT.
trace:  .
trace: (.
trace: MAJPRIO.
trace:  .
trace: ALTNP.
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: PARCOURS.
trace:  .
trace: (.
trace: ARG.
trace:  .
trace: x.
trace:  .
trace: (.
trace: (.
trace:  ... .
trace:  .
trace:  ... .
trace:  .... .
trace: ).
trace:  .
trace: PRINT.
trace:  .
trace: (.
trace:  ... .
trace:  .
trace:  ... .
trace:  .... .
trace: ).
trace:  .... .
trace: ).
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: VAR.
trace:  .
trace: GETVQ.
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: DANS.
trace:  .
trace: (.
trace: ARG.
trace:  .
trace: x.
trace:  .
trace: (.
trace: ARG.
trace:  .
trace: y.
trace:  .
trace: (.
trace:  ... .
trace:  .
trace:  ... .
trace:  .... .
trace: ).
trace:  .... .
trace: ).
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: RTRANSLIST1.
trace:  .
trace: (.
trace: C.
trace:  .
trace: Q.
trace:  .
trace: (.
trace: ARG.
trace:  .
trace: _tl_f.
trace:  .
trace: (.
trace:  ... .
trace:  .
trace:  ... .
trace:  .... .
trace: ).
trace:  .... .
trace: ).
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: TRANSLIST.
trace:  .
trace: (.
trace: C.
trace:  .
trace: Q.
trace:  .
trace: (.
trace: ARG.
trace:  .
trace: _tl_f.
trace:  .
trace: (.
trace:  ... .
trace:  .
trace:  ... .
trace:  .... .
trace: ).
trace:  .... .
trace: ).
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: LAST.
trace:  .
trace: (.
trace: ARG.
trace:  .
trace: l.
trace:  .
trace: (.
trace: (.
trace:  ... .
trace:  .
trace:  ... .
trace:  .... .
trace: ).
trace:  .
trace: NCONSPTHEN.
trace:  .
trace: (.
trace:  ... .
trace:  .
trace:  ... .
trace:  .... .
trace: ).
trace:  .... .
trace: ).
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: BUTLAST.
trace:  .
trace: (.
trace: ARG.
trace:  .
trace: l.
trace:  .
trace: (.
trace: (.
trace:  ... .
trace:  .
trace:  ... .
trace:  .... .
trace: ).
trace:  .
trace: NCONSPTHEN.
trace:  .
trace: (.
trace:  ... .
trace:  .
trace:  ... .
trace:  .... .
trace: ).
trace:  .... .
trace: ).
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: defprop.
trace:  .
trace: (.
trace: C.
trace:  .
trace: Q.
trace:  .
trace: (.
trace: C.
trace:  .
trace: Q.
trace:  .
trace: (.
trace:  ... .
trace:  .
trace:  ... .
trace:  .... .
trace: ).
trace:  .... .
trace: ).
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: GET.
trace:  .
trace: GETVSQ.
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: N_NEXT.
trace:  .
trace: (.
trace: 90.
trace:  .
trace: GETREG.
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: _UDF.
trace:  .
trace: (.
trace: C.
trace:  .
trace: Q.
trace:  .
trace: (.
trace: ARG.
trace:  .
trace: f.
trace:  .
trace: (.
trace:  ... .
trace:  .
trace:  ... .
trace:  .... .
trace: ).
trace:  .... .
trace: ).
trace: ).
trace: ).
trace: 
.
trace: (.
trace: def.
trace:  .
trace: _BRK.
trace:  .
trace: (.
trace: "\n*** BREAK ***\n".
trace:  .
trace: PRINTSTRING.
trace:  .
trace: STEPON.
trace: ).
trace: ).
trace: 
.
trace: LPIA> .
trace: (.
trace: a.
trace:  .
trace: b.
trace: ).
trace: 
.
trace: LPIA> .
trace: 
No code
.
trace: 
No code
.
trace: bye.
trace: 
.
trace: > .
